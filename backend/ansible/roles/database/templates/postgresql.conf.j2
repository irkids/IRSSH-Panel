# roles/database/templates/postgresql.conf.j2
# -----------------------------
# PostgreSQL configuration file
# -----------------------------

# CONNECTION SETTINGS
listen_addresses = '{{ postgresql_listen_addresses }}'
port = {{ postgresql_port }}
max_connections = {{ postgresql_max_connections }}

# MEMORY SETTINGS
shared_buffers = {{ postgresql_shared_buffers }}
work_mem = {{ postgresql_work_mem }}
maintenance_work_mem = {{ postgresql_maintenance_work_mem }}
effective_cache_size = {{ postgresql_effective_cache_size }}

# WRITE AHEAD LOG
wal_level = replica
checkpoint_timeout = 5min
max_wal_size = 1GB
min_wal_size = 80MB

# QUERY TUNING
random_page_cost = 1.1
effective_io_concurrency = 200

# ERROR REPORTING AND LOGGING
log_destination = 'csvlog'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 0
log_min_duration_statement = {{ postgresql_log_min_duration_statement }}

# SSL CONFIGURATION
{% if postgresql_ssl_enabled %}
ssl = on
ssl_cert_file = '/etc/postgresql/{{ postgresql_version }}/main/server.crt'
ssl_key_file = '/etc/postgresql/{{ postgresql_version }}/main/server.key'
{% else %}
ssl = off
{% endif %}

# AUTOVACUUM SETTINGS
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 1min
autovacuum_vacuum_threshold = 50
autovacuum_analyze_threshold = 50

# roles/database/templates/pg_hba.conf.j2
# PostgreSQL Client Authentication Configuration File

# TYPE  DATABASE        USER            ADDRESS                 METHOD

{% for entry in postgresql_hba_entries %}
{{ entry.type }}    {{ entry.database }}    {{ entry.user }}    {% if entry.address is defined %}{{ entry.address }}{% endif %}    {{ entry.auth_method }}
{% endfor %}

# roles/database/templates/backup.sh.j2
#!/bin/bash

# PostgreSQL Backup Script
# Generated by Ansible

# Configuration
BACKUP_DIR="{{ backup_directory }}"
RETENTION_DAYS="{{ backup_retention_days }}"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="{{ db_name }}"
DB_USER="{{ db_user }}"

# Create backup directory if it doesn't exist
mkdir -p "$BACKUP_DIR"

# Perform backup
PGPASSWORD="{{ db_password }}" pg_dump \
    -U "$DB_USER" \
    -h localhost \
    -d "$DB_NAME" \
    -F p \
    | gzip > "$BACKUP_DIR/$DB_NAME-$DATE.sql.gz"

# Check if backup was successful
if [ $? -eq 0 ]; then
    echo "Backup completed successfully: $DB_NAME-$DATE.sql.gz"
else
    echo "Backup failed!"
    exit 1
fi

# Clean up old backups
find "$BACKUP_DIR" -type f -name "*.sql.gz" -mtime +"$RETENTION_DAYS" -delete

# Send notification if configured
{% if postgresql_enable_monitoring %}
if [ -x "$(command -v curl)" ]; then
    curl -X POST http://localhost:8000/api/monitoring/backup-status \
        -H "Content-Type: application/json" \
        -d "{\"status\":\"success\",\"filename\":\"$DB_NAME-$DATE.sql.gz\",\"size\":$(stat -f%z "$BACKUP_DIR/$DB_NAME-$DATE.sql.gz")}"
fi
{% endif %}
